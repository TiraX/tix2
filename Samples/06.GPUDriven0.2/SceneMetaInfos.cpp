/*
	TiX Engine v2.0 Copyright (C) 2018~2021
	By ZhaoShuai tirax.cn@gmail.com
*/

#include "stdafx.h"
#include "SceneMetaInfos.h"

FSceneMetaInfos::FSceneMetaInfos()
	: Inited(false)
{
}

FSceneMetaInfos::~FSceneMetaInfos()
{
}

struct FDrawInstanceArgument
{
	uint32 IndexCountPerInstance;
	uint32 InstanceCount;
	uint32 StartIndexLocation;
	uint32 BaseVertexLocation;
	uint32 StartInstanceLocation;
};

void FSceneMetaInfos::PrepareSceneResources(FRHI* RHI, FScene * Scene, FGPUCommandSignaturePtr CommandSignature)
{
	// Re-collect instances and meshes
	if (Scene->HasSceneFlag(FScene::ScenePrimitivesDirty))
	{
		const THMap<FMeshBufferPtr, FSceneMeshInfo>& SceneMeshes = Scene->GetSceneMeshes();

		THMap<FMeshBufferPtr, int32> MeshOrderMap;
		MeshOrderMap.reserve(SceneMeshes.size());

		int32 MeshIndex = 0;
		uint32 TotalLoadedMeshes = (uint32)SceneMeshes.size();
		uint32 TotalLoadedOccludes = TotalLoadedMeshes;
		uint32 TotalClusters = 0;
		uint32 SceneMeshesVertexCount = 0;
		uint32 SceneMeshIndexCount = 0;
		uint32 SceneOccludeVertexCount = 0;
		uint32 SceneOccludeIndexCount = 0;
		uint32 VBFormat = 0;
		for (const auto& M : SceneMeshes)
		{
			FMeshBufferPtr MeshBuffer = M.first;

			// Remember mesh order
			MeshOrderMap[MeshBuffer] = MeshIndex;

			// Stat vertex and index count
			SceneMeshesVertexCount += MeshBuffer->GetVerticesCount();
			SceneMeshIndexCount += MeshBuffer->GetIndicesCount();
			TI_ASSERT(MeshBuffer->GetIndexType() == EIT_32BIT);	// Compute shader can only access 32bit aligned data
			TI_ASSERT(VBFormat == 0 || VBFormat == MeshBuffer->GetVSFormat());
			VBFormat = MeshBuffer->GetVSFormat();

			// Stat Occlude count
			FMeshBufferPtr OccludeMeshBuffer = M.second.OccludeMesh;
			TI_ASSERT(OccludeMeshBuffer != nullptr);	// OccludeMeshBuffer can be nullptr ???
			if (OccludeMeshBuffer != nullptr)
			{
				SceneOccludeVertexCount += OccludeMeshBuffer->GetVerticesCount();
				SceneOccludeIndexCount += OccludeMeshBuffer->GetIndicesCount();
				TI_ASSERT(OccludeMeshBuffer->GetVSFormat() == EVSSEG_POSITION);
				TI_ASSERT(OccludeMeshBuffer->GetIndexType() == EIT_32BIT);	// Compute shader can only access 32bit aligned data
			}

			// Stat cluster count
			TotalClusters += M.second.ClusterData->GetElements();

			++MeshIndex;
		}
		TI_ASSERT(SceneMeshesVertexCount > 0 && SceneMeshIndexCount > 0);

		const THMap<vector2di, FSceneTileResourcePtr>& SceneTileResources = Scene->GetSceneTiles();

		uint32 TotalSMInstances = 0;
		uint32 TotalDrawCommands = 0;
		TotalTrianglesInScene = 0;
		for (const auto& T : SceneTileResources)
		{
			FSceneTileResourcePtr TileRes = T.second;

			// Stat total instances count
			TotalSMInstances += TileRes->GetInstanceBuffer()->GetInstancesCount();

			// Stat total draw commands
			const TVector<FPrimitivePtr>& TilePrimitives = TileRes->GetPrimitives();

			for (auto Prim : TileRes->GetPrimitives())
			{
				if (Prim != nullptr)
				{
					TotalDrawCommands += Prim->GetInstanceCount();
					TotalTrianglesInScene += Prim->GetTriangles() * Prim->GetInstanceCount();
				}
			}
		}

		TI_ASSERT(TotalSMInstances == TotalDrawCommands); // ??? should be the same or NOT ??? I see not
		TI_ASSERT(TotalSMInstances > 0 && TotalLoadedMeshes > 0);
		TI_ASSERT(TotalClusters > 0);

		// Allocate space for draw arguments
		TVector<FDrawInstanceArgument> DrawArguments, OccludeDrawArguments;
		DrawArguments.resize(TotalDrawCommands);
		OccludeDrawArguments.resize(TotalDrawCommands);

		// Merge meshes and instances
		{
			// Create MergedMeshBuffer resource
			const uint32 VertexStride = TMeshBuffer::GetStrideFromFormat(VBFormat);
			MergedMeshBuffer = RHI->CreateEmptyMeshBuffer(EPT_TRIANGLELIST, VBFormat, SceneMeshesVertexCount, EIT_32BIT, SceneMeshIndexCount, aabbox3df());
			MergedMeshBuffer->SetResourceName("MergedMeshBuffer");
			RHI->UpdateHardwareResourceMesh(
				MergedMeshBuffer, 
				SceneMeshesVertexCount * VertexStride, 
				VertexStride, 
				SceneMeshIndexCount * sizeof(uint32), 
				EIT_32BIT, 
				"MergedMeshBuffer"
			);

			// Create MergedOccludeMeshBuffer resource
			MergedOccludeMeshBuffer = RHI->CreateEmptyMeshBuffer(EPT_TRIANGLELIST, EVSSEG_POSITION, SceneOccludeVertexCount, EIT_32BIT, SceneOccludeIndexCount, aabbox3df());
			MergedOccludeMeshBuffer->SetResourceName("MergedOccludeMeshBuffer");
			RHI->UpdateHardwareResourceMesh(
				MergedOccludeMeshBuffer, 
				SceneOccludeVertexCount * sizeof(vector3df), 
				sizeof(vector3df), 
				SceneOccludeIndexCount * sizeof(uint32), 
				EIT_32BIT, 
				"MergedOccludeMeshBuffer"
			);

			// Create MergedInstanceBuffer resource
			MergedInstanceBuffer = RHI->CreateEmptyInstanceBuffer(TotalSMInstances, TInstanceBuffer::InstanceStride);
			MergedInstanceBuffer->SetResourceName("MergedInstanceBuffer");
			RHI->UpdateHardwareResourceIB(MergedInstanceBuffer, nullptr);

			// Create MergedClusterMetaInfo
			const uint32 ClusterDataSize = sizeof(TMeshClusterData);
			MergedClusterMetaInfo = RHI->CreateUniformBuffer(ClusterDataSize, TotalClusters);
			MergedClusterMetaInfo->SetResourceName("MergedClusterMetaInfo");
			RHI->UpdateHardwareResourceUB(MergedClusterMetaInfo, nullptr);

			// Create Primitive BBox UniformBuffer resource
			SceneMeshBBoxesUniform = ti_new FSceneMeshBBoxes(TotalLoadedMeshes);

			// Create instance meta info UniformBuffer resource
			InstanceMetaInfoUniform = ti_new FSceneInstanceMetaInfo(TotalDrawCommands);

			uint32 SceneVBOffset = 0, SceneIBOffset = 0;
			uint32 OccludeVBOffset = 0, OccludeIBOffset = 0;
			uint32 ClusterOffset = 0;
			// X, Y = VBOffset, IBOffset;
			// Z, W = ClusterOffset, ClusterCount;
			THMap<FMeshBufferPtr, vector4di> MeshDataOffsets;
			THMap<FMeshBufferPtr, vector2di> OccludeMeshDataOffsets;
			MeshDataOffsets.reserve(SceneMeshes.size());
			OccludeMeshDataOffsets.reserve(SceneMeshes.size());
			for (const auto& M : SceneMeshes)
			{
				// Scene mesh buffer
				FMeshBufferPtr MeshBuffer = M.first;
				RHI->SetResourceStateMB(MeshBuffer, RESOURCE_STATE_COPY_SOURCE);
				RHI->CopyBufferRegion(
					MergedMeshBuffer,
					SceneVBOffset,
					SceneIBOffset,
					MeshBuffer,
					0,
					MeshBuffer->GetVerticesCount() * VertexStride,
					0,
					MeshBuffer->GetIndicesCount() * sizeof(uint32)
				);

				// Remember offset for this mesh
				const uint32 ClusterCount = M.second.ClusterData->GetElements();
				MeshDataOffsets[MeshBuffer] = vector4di(SceneVBOffset, SceneIBOffset, ClusterOffset, ClusterCount);

				// Increase offsets
				SceneVBOffset += MeshBuffer->GetVerticesCount() * VertexStride;
				SceneIBOffset += MeshBuffer->GetIndicesCount() * sizeof(uint32);
				TI_ASSERT(SceneVBOffset <= SceneMeshesVertexCount * VertexStride && SceneIBOffset <= SceneMeshIndexCount * sizeof(uint32));

				// Scene occlude mesh buffer
				FMeshBufferPtr OccludeMeshBuffer = M.second.OccludeMesh;
				TI_ASSERT(OccludeMeshBuffer != nullptr); // can be nullptr ???
				if (OccludeMeshBuffer != nullptr)
				{
					RHI->SetResourceStateMB(OccludeMeshBuffer, RESOURCE_STATE_COPY_SOURCE);
					RHI->CopyBufferRegion(
						MergedOccludeMeshBuffer,
						OccludeVBOffset,
						OccludeIBOffset,
						OccludeMeshBuffer,
						0,
						OccludeMeshBuffer->GetVerticesCount() * sizeof(vector3df),
						0,
						OccludeMeshBuffer->GetIndicesCount() * sizeof(uint32)
					);
					// Remember offset for this occlude mesh
					OccludeMeshDataOffsets[MeshBuffer] = vector2di(OccludeVBOffset, OccludeIBOffset);

					// Increase offsets
					OccludeVBOffset += OccludeMeshBuffer->GetVerticesCount() * sizeof(vector3df);
					OccludeIBOffset += OccludeMeshBuffer->GetIndicesCount() * sizeof(uint32);
					TI_ASSERT(OccludeVBOffset <= SceneOccludeVertexCount * sizeof(vector3df) && OccludeIBOffset <= SceneOccludeIndexCount * sizeof(uint32));
				}

				// Fill primitive bbox uniform buffer data
				const aabbox3df& BBox = MeshBuffer->GetBBox();
				const int32 MeshOrder = MeshOrderMap[MeshBuffer];
				SceneMeshBBoxesUniform->UniformBufferData[MeshOrder].MinEdge = FFloat4(BBox.MinEdge.X, BBox.MinEdge.Y, BBox.MinEdge.Z, 0.f);
				SceneMeshBBoxesUniform->UniformBufferData[MeshOrder].MaxEdge = FFloat4(BBox.MaxEdge.X, BBox.MaxEdge.Y, BBox.MaxEdge.Z, 0.f);

				// Copy Cluster meta info
				RHI->CopyBufferRegion(MergedClusterMetaInfo, ClusterOffset * ClusterDataSize, M.second.ClusterData, ClusterCount * ClusterDataSize);
				ClusterOffset += M.second.ClusterData->GetElements();
				TI_ASSERT(ClusterOffset <= TotalClusters);
			}
			TI_ASSERT(ClusterOffset == TotalClusters);

			uint32 InstanceDstOffset = 0;
			uint32 DrawCmdIndex = 0;
			TotalInstanceClusters = 0;
			uint32 IndexOffsetInExpandIndexBuffer = 0;
			for (const auto& T : SceneTileResources)
			{
				FSceneTileResourcePtr TileRes = T.second;

				// Merge meshes and collect primitive BBox
				{
					const TVector<FPrimitivePtr>& TilePrimitives = TileRes->GetPrimitives();

					// Copy mesh vertex and index to MergedMeshBuffer 
					// And record draw arguments
					for (auto Prim : TileRes->GetPrimitives())
					{
						if (Prim != nullptr)
						{
							// Remember draw arguments
							FMeshBufferPtr MeshBuffer = Prim->GetMeshBuffer();
							const vector4di& MeshDataOffset = MeshDataOffsets[MeshBuffer];

							// Scene occlude mesh buffer
							THMap<FMeshBufferPtr, FSceneMeshInfo>::const_iterator CIt = SceneMeshes.find(MeshBuffer);
							TI_ASSERT(CIt != SceneMeshes.end());
							FMeshBufferPtr OccludeMeshBuffer = CIt->second.OccludeMesh;
							TI_ASSERT(OccludeMeshBuffer != nullptr); // can be nullptr ???

							const int32 MeshOrder = MeshOrderMap[MeshBuffer];

							for (uint32 Ins = 0 ; Ins < Prim->GetInstanceCount() ; ++ Ins)
							{
								FDrawInstanceArgument& DrawArg = DrawArguments[DrawCmdIndex];
								DrawArg.IndexCountPerInstance = Prim->GetTriangles() * 3;
								// Trick: since instance count always be ONE. Use this variable as the draw call StartIndexLocation in the EXPANDED indices buffer
								DrawArg.InstanceCount = IndexOffsetInExpandIndexBuffer;
								DrawArg.StartIndexLocation = MeshDataOffset.Y / sizeof(uint32) + Prim->GetIndexStart();
								DrawArg.BaseVertexLocation = MeshDataOffset.X / VertexStride;
								DrawArg.StartInstanceLocation = InstanceDstOffset + Prim->GetInstanceOffset() + Ins;

								IndexOffsetInExpandIndexBuffer += DrawArg.IndexCountPerInstance;

								if (OccludeMeshBuffer != nullptr)
								{
									// Remember draw arguments
									const vector2di& OccludeMeshDataOffset = OccludeMeshDataOffsets[MeshBuffer];
									FDrawInstanceArgument& OccludeDrawArg = OccludeDrawArguments[DrawCmdIndex];
									OccludeDrawArg.IndexCountPerInstance = OccludeMeshBuffer->GetIndicesCount();
									OccludeDrawArg.InstanceCount = 1;
									OccludeDrawArg.StartIndexLocation = OccludeMeshDataOffset.Y / sizeof(uint32);
									OccludeDrawArg.BaseVertexLocation = OccludeMeshDataOffset.X / sizeof(vector3df);
									OccludeDrawArg.StartInstanceLocation = InstanceDstOffset + Prim->GetInstanceOffset() + Ins;
								}

								// Fill instance meta info uniform buffer data
								InstanceMetaInfoUniform->UniformBufferData[DrawCmdIndex].Info.X = MeshOrder;	// scene mesh index this instance link to, in FScene::SceneMeshes order, to access scene mesh bbox
								InstanceMetaInfoUniform->UniformBufferData[DrawCmdIndex].Info.Y = 1;	// Mark as Loaded

								InstanceMetaInfoUniform->UniformBufferData[DrawCmdIndex].Info.Z = MeshDataOffset.Z;	// cluster index begin
								InstanceMetaInfoUniform->UniformBufferData[DrawCmdIndex].Info.W = MeshDataOffset.W;	// cluster count

								TotalInstanceClusters += MeshDataOffset.W;

								++DrawCmdIndex;
							}
						}
					}
				}

				// Merge tile instances
				{
					FInstanceBufferPtr TileInstances = TileRes->GetInstanceBuffer();

					RHI->CopyBufferRegion(MergedInstanceBuffer, InstanceDstOffset, TileInstances, 0, TileInstances->GetInstancesCount());
					InstanceDstOffset += TileInstances->GetInstancesCount();
				}
			}
			TI_ASSERT(InstanceDstOffset == TotalSMInstances);
			TI_ASSERT(DrawCmdIndex == TotalDrawCommands);

			SceneMeshBBoxesUniform->InitUniformBuffer();
			InstanceMetaInfoUniform->InitUniformBuffer();
		}

		// Create scene indirect draw command buffer
		{
			// Scene indirect draw command buffer
			GPUCommandBuffer = RHI->CreateGPUCommandBuffer(CommandSignature, (uint32)DrawArguments.size(), UB_FLAG_GPU_COMMAND_BUFFER_RESOURCE);
			GPUCommandBuffer->SetResourceName("GPUCommandBuffer");

			uint32 CommandIndex = 0;
			for (const auto& Arg : DrawArguments)
			{
				GPUCommandBuffer->EncodeSetDrawIndexed(CommandIndex, 0,
					Arg.IndexCountPerInstance,
					Arg.InstanceCount,
					Arg.StartIndexLocation,
					Arg.BaseVertexLocation,
					Arg.StartInstanceLocation);
				++CommandIndex;
			}
			RHI->UpdateHardwareResourceGPUCommandBuffer(GPUCommandBuffer);

			// Occlude scene indirect draw command buffer
			GPUOccludeCommandBuffer = RHI->CreateGPUCommandBuffer(CommandSignature, (uint32)OccludeDrawArguments.size(), UB_FLAG_GPU_COMMAND_BUFFER_RESOURCE);
			GPUOccludeCommandBuffer->SetResourceName("GPUOccludeCommandBuffer");

			CommandIndex = 0;
			for (const auto& Arg : OccludeDrawArguments)
			{
				GPUOccludeCommandBuffer->EncodeSetDrawIndexed(CommandIndex, 0,
					Arg.IndexCountPerInstance,
					Arg.InstanceCount,
					Arg.StartIndexLocation,
					Arg.BaseVertexLocation,
					Arg.StartInstanceLocation);
				++CommandIndex;
			}
			RHI->UpdateHardwareResourceGPUCommandBuffer(GPUOccludeCommandBuffer);
		}

		Inited = true;
	}
}